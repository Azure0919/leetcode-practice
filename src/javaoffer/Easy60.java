package javaoffer;

import org.junit.Test;

/**
 * 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
 *
 * 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
 *
 * 示例 1:
 * 输入: 1
 * 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
 * 示例 2:
 * 输入: 2
 * 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
 *
 * 限制：
 * 1 <= n <= 11
 *
 *思路：n个骰子，每个骰子6个面，总情况数为6^n
 * 设F(n,s)F(n,s)为当骰子数为n，和为s的情况数量。
 * 当n=1时，F(1,s)=1,其中s=1,2,3,4,5,6当n=1时，F(1,s)=1,其中s=1,2,3,4,5,6
 * 当n≥2时，F(n,s)=F(n−1,s−1)+F(n−1,s−2)+F(n−1,s−3)+F(n−1,s−4)+F(n−1,s−5)+F(n−1,s−6)
 *
 */
public class Easy60 {
	public double[] twoSum(int n) {
		//dp[i][j]表示i个色子和为j的次数
		int[][] dp = new int[n + 1][6 * n + 1];
		//边界条件
		//1个色子和为1-6的次数都是1
		for (int s = 1; s <= 6; s++) dp[1][s] = 1;
		//从2个色子开始进入正题
		for (int i = 2; i <= n; i++) {
			for (int s = i; s <= 6 * i; s++) {
				//求dp[i][s]
				//比如dp[3][4]即3个色子和为4的情况等于，dp[2][2]+dp[1][2] + dp[2][3]+dp[1][1]
				for (int d = 1; d <= 6; d++) {
					if (s - d < i - 1) break;//为0了,如不存在dp[2][1],即2个色子和为1
					dp[i][s] += dp[i - 1][s - d];
				}
			}
		}
		double total = Math.pow(6, n);//概率等于：和的出现次数/总次数
		double[] ans = new double[5 * n + 1];
		for (int i = n; i <= 6 * n; i++) {
			ans[i - n] = ((double) dp[n][i]) / total;
		}
		return ans;
	}

	@Test
	public void test1() {

	}

}
